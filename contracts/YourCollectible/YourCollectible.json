{
  "id": "chatcmpl-9ctAVe1Y6dWsqZxdBW8hNMUCurQrD",
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "message": {
        "content": "Here is a sample implementation of the `YourCollectible` smart contract with the specified requirements:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract YourCollectible is ERC721URIStorage, ERC721Enumerable, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    string private _baseTokenURI;\n\n    constructor() ERC721(\"YourCollectible\", \"YCB\") {}\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    function setBaseURI(string memory baseURI) external onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    function mint(address to, string memory tokenURI) external onlyOwner returns (uint256) {\n        _tokenIdCounter.increment();\n        uint256 newTokenId = _tokenIdCounter.current();\n        _safeMint(to, newTokenId);\n        _setTokenURI(newTokenId, tokenURI);\n        return newTokenId;\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        return ERC721URIStorage.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function _increaseBalance(address to) internal override(ERC721, ERC721Enumerable) {\n        super._increaseBalance(to);\n    }\n\n    function _update(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {\n        super._update(from, to, tokenId);\n    }\n}\n```\n\nPlease note that you need to install the required OpenZeppelin contracts using npm or yarn and import them into your Solidity project. Also, make sure to compile the contract using a compatible Solidity compiler version (e.g., 0.8.0).\n\nThis contract provides the basic functionality of an ERC721 collectible with the specified overrides and extensions. Make sure to thoroughly test the contract before deploying it to a live network.",
        "role": "assistant",
        "function_call": null,
        "tool_calls": null
      }
    }
  ],
  "created": 1719055559,
  "model": "gpt-3.5-turbo-0125",
  "object": "chat.completion",
  "system_fingerprint": null,
  "usage": {
    "completion_tokens": 577,
    "prompt_tokens": 333,
    "total_tokens": 910
  },
  "query": "As a Senior Web3 Solidity Developer, please develop a smart contract for Your Collectible with the following specifications:\n\n- The contract is a simple ERC721 contract that allows users to mint a token.\n- The name of the contract is `YourCollectible` and its symbol is `YCB`.\n- The contract follows the OpenZeppelin implementation of the ERC721 standard (ERC721 interface). Additionally, it uses the `Counters` library to manage token IDs, the `ERC721URIStorage` extension to store token URIs, the `ERC721Enumerable` extension to enable enumeration of tokens and the `Ownable` extension to restrict access to certain functions.\n- The mint function first increments the token ID and then mints a new token with the given URI.\n- The contract also override the `_baseURI` function to return the base URI for the token metadata, which is `https://ipfs.io/ipfs/`, the `_beforeTokenTransfer` function to check if the token is being transferred to a valid address, and the `_burn` function to handle token burning. \n- Moreover, the contract has a `tokenURI` function to retrieve the URI of a specific token and `supportsInterface` function to check if the contract supports a given interface ID.\n- The contract should override `_increaseBalance` and `_update` function.\n\nPlease ensure that the smart contract is meticulously designed, with functions named efficiently and systematically, and that the correct compiler version is used. Also, the contract should not have any syntax errors."
}